<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>honeybee._hbanalysissurface API documentation</title>
    <meta name="description" content="" />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 0.9em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    margin-left: 25%;
    max-width: 90%;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    position: fixed;
    height: 100%;
    width: 25%;
    float: left;
    padding: 30px;
    overflow: auto;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  }

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; }

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;

      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: auto;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  .desc {
    white-space: pre-wrap;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      position: inherit;
      float: none;
      width: auto;
    }
    #content {
      width: 95%;
      margin-left: auto;
      border-left: none;
      padding: 30px;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>

  <style type="text/css">
  .codehilite .hll { background-color: #ffffcc }
.codehilite  { background: #f8f8f8; }
.codehilite .c { color: #408080; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #FF0000 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666666 } /* Operator */
.codehilite .ch { color: #408080; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #BC7A00 } /* Comment.Preproc */
.codehilite .cpf { color: #408080; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #408080; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #408080; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .gr { color: #FF0000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #00A000 } /* Generic.Inserted */
.codehilite .go { color: #888888 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #0044DD } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #7D9029 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.codehilite .no { color: #880000 } /* Name.Constant */
.codehilite .nd { color: #AA22FF } /* Name.Decorator */
.codehilite .ni { color: #999999; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #0000FF } /* Name.Function */
.codehilite .nl { color: #A0A000 } /* Name.Label */
.codehilite .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #bbbbbb } /* Text.Whitespace */
.codehilite .mb { color: #666666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666666 } /* Literal.Number.Float */
.codehilite .mh { color: #666666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #BB6688 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #0000FF } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666666 } /* Literal.Number.Integer.Long */
  </style>

  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">


    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#honeybee._hbanalysissurface.AnalsysiSurfacePolyline">AnalsysiSurfacePolyline</a></span>
        
          
  <ul>
    <li class="mono"><a href="#honeybee._hbanalysissurface.AnalsysiSurfacePolyline.distance">distance</a></li>
    <li class="mono"><a href="#honeybee._hbanalysissurface.AnalsysiSurfacePolyline.__init__">__init__</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#honeybee._hbanalysissurface.HBAnalysisSurface">HBAnalysisSurface</a></span>
        
          
  <ul>
    <li class="mono"><a href="#honeybee._hbanalysissurface.HBAnalysisSurface.__init__">__init__</a></li>
    <li class="mono"><a href="#honeybee._hbanalysissurface.HBAnalysisSurface.ToString">ToString</a></li>
    <li class="mono"><a href="#honeybee._hbanalysissurface.HBAnalysisSurface.add_point">add_point</a></li>
    <li class="mono"><a href="#honeybee._hbanalysissurface.HBAnalysisSurface.add_point_list">add_point_list</a></li>
    <li class="mono"><a href="#honeybee._hbanalysissurface.HBAnalysisSurface.add_surface_state">add_surface_state</a></li>
    <li class="mono"><a href="#honeybee._hbanalysissurface.HBAnalysisSurface.duplicate">duplicate</a></li>
    <li class="mono"><a href="#honeybee._hbanalysissurface.HBAnalysisSurface.duplicate_vertices">duplicate_vertices</a></li>
    <li class="mono"><a href="#honeybee._hbanalysissurface.HBAnalysisSurface.from_rad_ep_properties">from_rad_ep_properties</a></li>
    <li class="mono"><a href="#honeybee._hbanalysissurface.HBAnalysisSurface.rad_string_to_file">rad_string_to_file</a></li>
    <li class="mono"><a href="#honeybee._hbanalysissurface.HBAnalysisSurface.radiance_materials">radiance_materials</a></li>
    <li class="mono"><a href="#honeybee._hbanalysissurface.HBAnalysisSurface.to_rad_string">to_rad_string</a></li>
    <li class="mono"><a href="#honeybee._hbanalysissurface.HBAnalysisSurface.toep_string">toep_string</a></li>
  </ul>

        </li>
      </ul>
    </li>

    
    <li class="set"><h3>Module Index :: <a href="../honeybee/index.html">honeybee</a></h3>
    
    <ul>
      <li class="mono"><a href="../honeybee/config.m.html">config</a></li>
      

      <li class="mono"><a href="../honeybee/dataoperation.m.html">dataoperation</a></li>
      

      <li class="mono"><a href="../honeybee/energyplus/index.html">energyplus</a></li>
      
    <ul>
      <li class="mono"><a href="../honeybee/energyplus/filemanager.m.html">filemanager</a></li>
      

      <li class="mono"><a href="../honeybee/energyplus/geometryrules.m.html">geometryrules</a></li>
      

    </ul>

      <li class="mono"><a href="../honeybee/futil.m.html">futil</a></li>
      

      <li class="mono"><a href="../honeybee/geometryoperation.m.html">geometryoperation</a></li>
      

      <li class="mono"><a href="../honeybee/hbdynamicsurface.m.html">hbdynamicsurface</a></li>
      

      <li class="mono"><a href="../honeybee/hbfensurface.m.html">hbfensurface</a></li>
      

      <li class="mono"><a href="../honeybee/hbobject.m.html">hbobject</a></li>
      

      <li class="mono"><a href="../honeybee/hbshadesurface.m.html">hbshadesurface</a></li>
      

      <li class="mono"><a href="../honeybee/hbsurface.m.html">hbsurface</a></li>
      

      <li class="mono"><a href="../honeybee/hbzone.m.html">hbzone</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/index.html">radiance</a></li>
      
    <ul>
      <li class="mono"><a href="../honeybee/radiance/analysisgrid.m.html">analysisgrid</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/analysispoint.m.html">analysispoint</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/command/index.html">command</a></li>
      
    <ul>
      <li class="mono"><a href="../honeybee/radiance/command/dctimestep.m.html">dctimestep</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/command/epw2wea.m.html">epw2wea</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/command/falsecolor.m.html">falsecolor</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/command/genBSDF.m.html">genBSDF</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/command/gendaylit.m.html">gendaylit</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/command/gendaymtx.m.html">gendaymtx</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/command/gensky.m.html">gensky</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/command/genskyvec.m.html">genskyvec</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/command/getbbox.m.html">getbbox</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/command/getinfo.m.html">getinfo</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/command/objview.m.html">objview</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/command/oconv.m.html">oconv</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/command/pcomb.m.html">pcomb</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/command/pyRad/index.html">pyRad</a></li>
      
    <ul>
      <li class="mono"><a href="../honeybee/radiance/command/pyRad/objview.m.html">objview</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/command/pyRad/pyRadLib/index.html">pyRadLib</a></li>
      
    <ul>
      <li class="mono"><a href="../honeybee/radiance/command/pyRad/pyRadLib/pyrad_proc.m.html">pyrad_proc</a></li>
      

    </ul>

    </ul>

      <li class="mono"><a href="../honeybee/radiance/command/raBmp.m.html">raBmp</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/command/raTiff.m.html">raTiff</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/command/rcalc.m.html">rcalc</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/command/rcollate.m.html">rcollate</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/command/rcontrib.m.html">rcontrib</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/command/rfluxmtx.m.html">rfluxmtx</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/command/rmtxop.m.html">rmtxop</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/command/rpict.m.html">rpict</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/command/rtrace.m.html">rtrace</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/command/vwrays.m.html">vwrays</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/command/xform.m.html">xform</a></li>
      

    </ul>

      <li class="mono"><a href="../honeybee/radiance/datatype.m.html">datatype</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/filemanager.m.html">filemanager</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/geometry.m.html">geometry</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/imagecollection.m.html">imagecollection</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/material/index.html">material</a></li>
      
    <ul>
      <li class="mono"><a href="../honeybee/radiance/material/bsdf.m.html">bsdf</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/material/custom.m.html">custom</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/material/glass.m.html">glass</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/material/glow.m.html">glow</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/material/light.m.html">light</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/material/metal.m.html">metal</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/material/plastic.m.html">plastic</a></li>
      

    </ul>

      <li class="mono"><a href="../honeybee/radiance/parameters/index.html">parameters</a></li>
      
    <ul>
      <li class="mono"><a href="../honeybee/radiance/parameters/dctimestep.m.html">dctimestep</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/parameters/falsecolor.m.html">falsecolor</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/parameters/genBsdf.m.html">genBsdf</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/parameters/gendaylit.m.html">gendaylit</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/parameters/gendaymtx.m.html">gendaymtx</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/parameters/gensky.m.html">gensky</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/parameters/gridbased.m.html">gridbased</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/parameters/imagebased.m.html">imagebased</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/parameters/oconv.m.html">oconv</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/parameters/pcomb.m.html">pcomb</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/parameters/raBmp.m.html">raBmp</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/parameters/raTiff.m.html">raTiff</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/parameters/rcalc.m.html">rcalc</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/parameters/rcollate.m.html">rcollate</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/parameters/rcontrib.m.html">rcontrib</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/parameters/rfluxmtx.m.html">rfluxmtx</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/parameters/rmtxop.m.html">rmtxop</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/parameters/vwrays.m.html">vwrays</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/parameters/xform.m.html">xform</a></li>
      

    </ul>

      <li class="mono"><a href="../honeybee/radiance/properties.m.html">properties</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/radfile.m.html">radfile</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/recipe/index.html">recipe</a></li>
      
    <ul>
      <li class="mono"><a href="../honeybee/radiance/recipe/annual/index.html">annual</a></li>
      
    <ul>
      <li class="mono"><a href="../honeybee/radiance/recipe/annual/gridbased.m.html">gridbased</a></li>
      

    </ul>

      <li class="mono"><a href="../honeybee/radiance/recipe/daylightcoeff/index.html">daylightcoeff</a></li>
      
    <ul>
      <li class="mono"><a href="../honeybee/radiance/recipe/daylightcoeff/gridbased.m.html">gridbased</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/recipe/daylightcoeff/imagebased.m.html">imagebased</a></li>
      

    </ul>

      <li class="mono"><a href="../honeybee/radiance/recipe/daylightfactor/index.html">daylightfactor</a></li>
      
    <ul>
      <li class="mono"><a href="../honeybee/radiance/recipe/daylightfactor/gridbased.m.html">gridbased</a></li>
      

    </ul>

      <li class="mono"><a href="../honeybee/radiance/recipe/fivephase/index.html">fivephase</a></li>
      
    <ul>
      <li class="mono"><a href="../honeybee/radiance/recipe/fivephase/gridbased.m.html">gridbased</a></li>
      

    </ul>

      <li class="mono"><a href="../honeybee/radiance/recipe/parameters.m.html">parameters</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/recipe/pointintime/index.html">pointintime</a></li>
      
    <ul>
      <li class="mono"><a href="../honeybee/radiance/recipe/pointintime/gridbased.m.html">gridbased</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/recipe/pointintime/imagebased.m.html">imagebased</a></li>
      

    </ul>

      <li class="mono"><a href="../honeybee/radiance/recipe/radiation/index.html">radiation</a></li>
      
    <ul>
      <li class="mono"><a href="../honeybee/radiance/recipe/radiation/gridbased.m.html">gridbased</a></li>
      

    </ul>

      <li class="mono"><a href="../honeybee/radiance/recipe/recipedcutil.m.html">recipedcutil</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/recipe/recipeutil.m.html">recipeutil</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/recipe/recipexphaseutil.m.html">recipexphaseutil</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/recipe/solaraccess/index.html">solaraccess</a></li>
      
    <ul>
      <li class="mono"><a href="../honeybee/radiance/recipe/solaraccess/gridbased.m.html">gridbased</a></li>
      

    </ul>

      <li class="mono"><a href="../honeybee/radiance/recipe/threephase/index.html">threephase</a></li>
      
    <ul>
      <li class="mono"><a href="../honeybee/radiance/recipe/threephase/gridbased.m.html">gridbased</a></li>
      

    </ul>

    </ul>

      <li class="mono"><a href="../honeybee/radiance/runmanager.m.html">runmanager</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/scene.m.html">scene</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/sky/index.html">sky</a></li>
      
    <ul>
      <li class="mono"><a href="../honeybee/radiance/sky/certainIlluminance.m.html">certainIlluminance</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/sky/cie.m.html">cie</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/sky/climatebased.m.html">climatebased</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/sky/gendaylit.m.html">gendaylit</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/sky/skymatrix.m.html">skymatrix</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/sky/skyvector.m.html">skyvector</a></li>
      

      <li class="mono"><a href="../honeybee/radiance/sky/sunmatrix.m.html">sunmatrix</a></li>
      

    </ul>

      <li class="mono"><a href="../honeybee/radiance/view.m.html">view</a></li>
      

    </ul>

      <li class="mono"><a href="../honeybee/room.m.html">room</a></li>
      

      <li class="mono"><a href="../honeybee/schedule.m.html">schedule</a></li>
      

      <li class="mono"><a href="../honeybee/surfaceproperties.m.html">surfaceproperties</a></li>
      

      <li class="mono"><a href="../honeybee/surfacetype.m.html">surfacetype</a></li>
      

      <li class="mono"><a href="../honeybee/utilcol.m.html">utilcol</a></li>
      

      <li class="mono"><a href="../honeybee/vectormath/index.html">vectormath</a></li>
      
    <ul>
      <li class="mono"><a href="../honeybee/vectormath/euclid.m.html">euclid</a></li>
      

    </ul>

    </ul>

    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">honeybee._hbanalysissurface</span> module</h1>
  
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-honeybee._hbanalysissurface', this);">Show source &equiv;</a></p>
  <div id="source-honeybee._hbanalysissurface" class="source">
    <div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABCMeta</span><span class="p">,</span> <span class="n">abstractproperty</span>
<span class="kn">import</span> <span class="nn">utilcol</span> <span class="kn">as</span> <span class="nn">util</span>
<span class="kn">from</span> <span class="nn">hbobject</span> <span class="kn">import</span> <span class="n">HBObject</span>
<span class="kn">from</span> <span class="nn">surfaceproperties</span> <span class="kn">import</span> <span class="n">SurfaceProperties</span><span class="p">,</span> <span class="n">SurfaceState</span>
<span class="kn">import</span> <span class="nn">surfacetype</span>
<span class="kn">import</span> <span class="nn">geometryoperation</span> <span class="kn">as</span> <span class="nn">go</span>
<span class="kn">from</span> <span class="nn">surfacetype</span> <span class="kn">import</span> <span class="n">Floor</span><span class="p">,</span> <span class="n">Wall</span><span class="p">,</span> <span class="n">Window</span><span class="p">,</span> <span class="n">Ceiling</span>
<span class="kn">from</span> <span class="nn">radiance.radfile</span> <span class="kn">import</span> <span class="n">RadFile</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">types</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">copy</span>


<span class="k">class</span> <span class="nc">HBAnalysisSurface</span><span class="p">(</span><span class="n">HBObject</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class for Honeybee surface.</span>

<span class="sd">    Args:</span>
<span class="sd">        name: A unique string for surface name</span>
<span class="sd">        sorted_points: A list of 3 points or more as tuple or list with three items</span>
<span class="sd">            (x, y, z). Points should be sorted. This class won&#39;t sort the points.</span>
<span class="sd">            If surfaces has multiple subsurfaces you can pass lists of point lists</span>
<span class="sd">            to this function (e.g. ((0, 0, 0), (10, 0, 0), (0, 10, 0))).</span>
<span class="sd">        surface_type: Optional input for surface type. You can use any of the surface</span>
<span class="sd">            types available from surfacetype libraries or use a float number to</span>
<span class="sd">            indicate the type. If not indicated it will be assigned based on normal</span>
<span class="sd">            angle of the surface which will be calculated from surface points.</span>
<span class="sd">                0.0: Wall           0.5: UndergroundWall</span>
<span class="sd">                1.0: Roof           1.5: UndergroundCeiling</span>
<span class="sd">                2.0: Floor          2.25: UndergroundSlab</span>
<span class="sd">                2.5: SlabOnGrade    2.75: ExposedFloor</span>
<span class="sd">                3.0: Ceiling        4.0: AirWall</span>
<span class="sd">                5.0: Window         6.0: Context</span>
<span class="sd">        is_name_set_by_user: If you want the name to be changed by honeybee any case</span>
<span class="sd">            set is_name_set_by_user to True. Default is set to False which let Honeybee</span>
<span class="sd">            to rename the surface in cases like creating a newHBZone.</span>
<span class="sd">        states: A collection of SurfaceStates. SurfaceStates includes SurfaceProperties</span>
<span class="sd">            which includes the data for RadianceProperties and EPProperties and optional</span>
<span class="sd">            HBSurfaces. Each</span>
<span class="sd">            item in this collection stands for a different stae of the materials. Use</span>
<span class="sd">            the properties to model dynamic bahaviors such as dynamic blinds.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__metaclass__</span> <span class="o">=</span> <span class="n">ABCMeta</span>
    <span class="n">_surface_types</span> <span class="o">=</span> <span class="p">{</span><span class="mf">0.0</span><span class="p">:</span> <span class="s1">&#39;Wall&#39;</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">:</span> <span class="s1">&#39;UndergroundWall&#39;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">:</span> <span class="s1">&#39;Roof&#39;</span><span class="p">,</span>
                      <span class="mf">1.5</span><span class="p">:</span> <span class="s1">&#39;UndergroundCeiling&#39;</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">:</span> <span class="s1">&#39;Floor&#39;</span><span class="p">,</span>
                      <span class="mf">2.25</span><span class="p">:</span> <span class="s1">&#39;UndergroundSlab&#39;</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">:</span> <span class="s1">&#39;SlabOnGrade&#39;</span><span class="p">,</span>
                      <span class="mf">2.75</span><span class="p">:</span> <span class="s1">&#39;ExposedFloor&#39;</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">:</span> <span class="s1">&#39;Ceiling&#39;</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">:</span> <span class="s1">&#39;AirWall&#39;</span><span class="p">,</span>
                      <span class="mf">6.0</span><span class="p">:</span> <span class="s1">&#39;Context&#39;</span><span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">sorted_points</span><span class="p">,</span> <span class="n">surface_type</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">is_name_set_by_user</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                 <span class="n">is_type_set_by_user</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">states</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize Honeybee Surface.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_childSurfaces</span> <span class="o">=</span> <span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_states</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">random_name</span><span class="p">()</span>
            <span class="n">is_name_set_by_user</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">is_name_set_by_user</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;Surface name.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">sorted_points</span>
        <span class="sd">&quot;&quot;&quot;A list of points as tuples or lists of (x, y, z).</span>
<span class="sd">        Points should be sorted. This class won&#39;t sort the points.</span>
<span class="sd">        (e.g. ((0, 0, 0), (10, 0, 0), (0, 10, 0)))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surface_type</span> <span class="o">=</span> <span class="p">(</span><span class="n">surface_type</span><span class="p">,</span> <span class="n">is_type_set_by_user</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;Surface type.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="sd">&quot;&quot;&quot;Current state of the surface.&quot;&quot;&quot;</span>
        <span class="n">states</span> <span class="o">=</span> <span class="n">states</span> <span class="ow">or</span> \
            <span class="p">(</span><span class="n">SurfaceState</span><span class="p">(</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="n">SurfaceProperties</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surface_type</span><span class="p">)),)</span>
        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">states</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_surface_state</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_rad_ep_properties</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">sorted_points</span><span class="p">,</span> <span class="n">surface_type</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">is_name_set_by_user</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
            <span class="n">is_type_set_by_user</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">rad_properties</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ep_properties</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
            <span class="n">states</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize Honeybee Surface.</span>

<span class="sd">        RadianceProperties and EPProperties will be used to create the initial state.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">states</span> <span class="o">=</span> <span class="n">states</span> <span class="ow">or</span> <span class="p">()</span>
        <span class="c1"># create the surface first to get the surface type if not available</span>
        <span class="n">_cls</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">sorted_points</span><span class="p">,</span>
            <span class="n">surface_type</span><span class="p">,</span>
            <span class="n">is_name_set_by_user</span><span class="p">,</span>
            <span class="n">is_type_set_by_user</span><span class="p">)</span>
        <span class="c1"># replace the default properties for the initial state</span>
        <span class="n">sp</span> <span class="o">=</span> <span class="n">SurfaceProperties</span><span class="p">(</span><span class="n">_cls</span><span class="o">.</span><span class="n">surface_type</span><span class="p">,</span> <span class="n">rad_properties</span><span class="p">,</span> <span class="n">ep_properties</span><span class="p">)</span>
        <span class="n">_cls</span><span class="o">.</span><span class="n">_states</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">SurfaceState</span><span class="p">(</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="n">sp</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">states</span><span class="p">:</span>
            <span class="n">_cls</span><span class="o">.</span><span class="n">add_surface_state</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">_cls</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_hb_analysis_surface</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True for HBSurface.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_hb_surface</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True for HBSurfaces.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_hb_fen_surface</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True for HBFenSurfaces.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_hb_dynamic_surface</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True for HBSurfaces.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="nd">@abstractproperty</span>
    <span class="k">def</span> <span class="nf">is_child_surface</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if Honeybee surface is Fenestration Surface.&quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_child_surfaces</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if surface has children surfaces.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">children_surfaces</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get children surfaces.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_childSurfaces</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_bsdf_radiance_material</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if .xml BSDF material is assigned for radiance material.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_hb_fen_surface</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">radiance_material</span><span class="p">,</span> <span class="s1">&#39;xmlfile&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_radiance_glass_material</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return true if surface has radiance glass material.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">radiance_material</span><span class="o">.</span><span class="n">is_glass_material</span>

    <span class="nd">@abstractproperty</span>
    <span class="k">def</span> <span class="nf">parent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return parent for HBAnalysisSurface.</span>

<span class="sd">        Parent will be a HBZone for a HBSurface, and a HBSurface for a</span>
<span class="sd">        HBFenSurface.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_relative_system</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if coordinate system is relative.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">is_relative_system</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">origin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get origin of the coordinate system for this surface.</span>

<span class="sd">        For Absolute system the value is always (0, 0, 0).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">origin</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">state_count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of states for this surface.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The current state id.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span>

    <span class="nd">@state.setter</span>
    <span class="k">def</span> <span class="nf">state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">count</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The current state id.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">count</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_count</span><span class="p">,</span> \
                <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;This surface has only {} state. {} is an invalid state.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">state_count</span><span class="p">,</span> <span class="n">count</span>
                    <span class="p">)</span>
                <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="n">count</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">states</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;List of states for this surface.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_states</span>

    <span class="k">def</span> <span class="nf">add_surface_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">srf_state</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">srf_state</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">srf_state</span><span class="p">,</span> <span class="s1">&#39;isSurfaceState&#39;</span><span class="p">),</span> \
            <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Expected SurfaceState not {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">srf_state</span><span class="p">)))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">srf_state</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Retuen surface name.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>

    <span class="nd">@name.setter</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set name and isSetByUser property.</span>

<span class="sd">        Args:</span>
<span class="sd">            values: A name or a tuple as (name, isSetByUser)</span>

<span class="sd">        Usage:</span>
<span class="sd">            HBSrf.name = &quot;surface_001&quot;</span>
<span class="sd">            # or</span>
<span class="sd">            HBSrf.name = (&quot;mySurfaceName&quot;, True)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># check if user passed a tuple</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span>
            <span class="n">new_name</span><span class="p">,</span> <span class="n">is_name_set_by_user</span> <span class="o">=</span> <span class="n">values</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="c1"># user is passing a list or tuple with one ValueError</span>
            <span class="n">new_name</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">is_name_set_by_user</span> <span class="o">=</span> <span class="bp">False</span>  <span class="c1"># if not indicated assume it is not set by user.</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="c1"># user just passed a single value which is the name</span>
            <span class="n">new_name</span> <span class="o">=</span> <span class="n">values</span>
            <span class="n">is_name_set_by_user</span> <span class="o">=</span> <span class="bp">False</span>  <span class="c1"># if not indicated assume it is not set by user.</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="c1"># set new name</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">new_name</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_name_set_by_user</span> <span class="o">=</span> <span class="n">is_name_set_by_user</span>
            <span class="n">util</span><span class="o">.</span><span class="n">check_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_name_set_by_user</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return if name is set by user.</span>

<span class="sd">        If name is set by user the surface will never be renamed automatically.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_name_set_by_user</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">surface_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return Honeybee valid surface types.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_surface_types</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">surface_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get and set Surface Type.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_surface_type</span>

    <span class="nd">@surface_type.setter</span>
    <span class="k">def</span> <span class="nf">surface_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="c1"># let&#39;s assume values in surface_type and Boolean</span>
        <span class="n">_surface_type</span><span class="p">,</span> <span class="n">is_type_set_by_user</span> <span class="o">=</span> <span class="n">values</span>

        <span class="c1"># Now let&#39;s check the input for surface type</span>
        <span class="k">if</span> <span class="n">_surface_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c1"># it is either a number or already a valid type</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_surface_type</span><span class="p">,</span> <span class="n">surfacetype</span><span class="o">.</span><span class="n">SurfaceTypeBase</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_surface_type</span> <span class="o">=</span> <span class="n">_surface_type</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># it should be a key value</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_surface_type</span> <span class="o">=</span> \
                        <span class="n">surfacetype</span><span class="o">.</span><span class="n">SurfaceTypes</span><span class="o">.</span><span class="n">get_type_by_key</span><span class="p">(</span><span class="n">_surface_type</span><span class="p">)()</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> is not a valid surface type.&#39;</span> <span class="o">%</span> <span class="n">_surface_type</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># try to figure it out based on points</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_surface_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_surface_type_from_points</span><span class="p">()</span>
            <span class="n">is_type_set_by_user</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_is_type_set_by_user</span> <span class="o">=</span> <span class="n">is_type_set_by_user</span>

    <span class="k">def</span> <span class="nf">_surface_type_from_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">normal</span> <span class="o">=</span> <span class="n">go</span><span class="o">.</span><span class="n">normal_from_points</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">angle_to_z_axis</span> <span class="o">=</span> <span class="n">go</span><span class="o">.</span><span class="n">vector_angleToZAxis</span><span class="p">(</span><span class="n">normal</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">surfacetype</span><span class="o">.</span><span class="n">SurfaceTypes</span><span class="o">.</span><span class="n">by_normal_angle_and_points</span><span class="p">(</span><span class="n">angle_to_z_axis</span><span class="p">,</span>
                                                                   <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">])()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_type_set_by_user</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if the type for surface is set by user.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_type_set_by_user</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_floor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if surface is a Floor.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surface_type</span><span class="p">,</span> <span class="n">Floor</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_wall</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if surface is a Wall.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surface_type</span><span class="p">,</span> <span class="n">Wall</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_ceiling</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if surface is a Ceiling.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surface_type</span><span class="p">,</span> <span class="n">Ceiling</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_window</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if surface is a Window.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surface_type</span><span class="p">,</span> <span class="n">Window</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get/set points.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_points</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">absolute_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return absolute coordinates of points.</span>

<span class="sd">        If coordinate system is absolute, self.absolute_points will be the same</span>
<span class="sd">        as self.points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_relative_system</span><span class="p">:</span>
            <span class="n">ptgroups</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">count</span><span class="p">,</span> <span class="n">ptGroup</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">):</span>
                <span class="n">ptgroups</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                     <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                     <span class="n">pt</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">ptGroup</span>
                <span class="p">]</span>
            <span class="k">return</span> <span class="n">ptgroups</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span>

    <span class="nd">@points.setter</span>
    <span class="k">def</span> <span class="nf">points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pts</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;set points.</span>

<span class="sd">        Args:</span>
<span class="sd">            pts: A list of points as tuples or lists of (x, y, z).</span>
<span class="sd">            Points should be sorted. This class won&#39;t sort the points.</span>
<span class="sd">            (e.g. ((0, 0, 0), (10, 0, 0), (0, 10, 0)))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># The structure of points is list of lists so it can handle non-planar</span>
        <span class="c1"># surfaces which will have several subsurfaces. We don&#39;t check the structure</span>
        <span class="c1"># here so user can add points as needed. It will be checked once user wants</span>
        <span class="c1"># to write the surface to Radiance or EnergyPlus</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_points</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_point_list</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;is_type_set_by_user&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_type_set_by_user</span><span class="p">:</span>
            <span class="c1"># re-evaluate the type if it hasn&#39;t been set by user</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_surface_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_surface_type_from_points</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">add_point_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pts</span><span class="p">,</span> <span class="n">remove_current_points</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add new list of points to surface points.</span>

<span class="sd">        Args:</span>
<span class="sd">            pts: A list of points as tuples or lists of (x, y, z).</span>
<span class="sd">                Points should be sorted. This class won&#39;t sort the points.</span>
<span class="sd">                (e.g. ((0, 0, 0), (10, 0, 0), (0, 10, 0)))</span>
<span class="sd">            remove_current_points: Set to True to remove current points.</span>
<span class="sd">                (Default: False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">GeneratorType</span><span class="p">)),</span> \
            <span class="s1">&#39;Points should be a list or a tuple or a generator not {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">pts</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">remove_current_points</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_points</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;X&#39;</span><span class="p">):</span>
            <span class="c1"># a single list of points from Dynamo</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">((</span><span class="n">pt</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">Z</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">pts</span><span class="p">))</span>

        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;__iter__&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;X&#39;</span><span class="p">):</span>
            <span class="c1"># list of points list in Dynamo</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">tuple</span><span class="p">((</span><span class="n">pt</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">Z</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">ptGroup</span><span class="p">)</span>
                                      <span class="k">for</span> <span class="n">ptGroup</span> <span class="ow">in</span> <span class="n">pts</span><span class="p">))</span>

        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;__iter__&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;__iter__&#39;</span><span class="p">):</span>
            <span class="c1"># a list of tuples as x, y, z</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pts</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;__iter__&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;__iter__&#39;</span><span class="p">):</span>
            <span class="c1"># a list of list of tuples</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pts</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid structure for input points: {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pts</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">add_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pt</span><span class="p">,</span> <span class="n">subsurface_number</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a single point to current surface points.</span>

<span class="sd">        Args:</span>
<span class="sd">            pt: A point as (x, y, z) e.g. (20, 20, 10)</span>
<span class="sd">            subsurface_number: An optional input to indicate the subsurface that</span>
<span class="sd">            point should be added to (Default is -1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="n">subsurface_number</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="c1"># pts is a flattened list</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">pt</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c1"># input is a tuple or a generator</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="n">subsurface_number</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="n">subsurface_number</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="n">subsurface_number</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">normal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return surface normal for the first face.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">go</span><span class="o">.</span><span class="n">normal_from_points</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">normals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return surface normals for all faces.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">go</span><span class="o">.</span><span class="n">normal_from_points</span><span class="p">(</span><span class="n">pts</span><span class="p">)</span> <span class="k">for</span> <span class="n">pts</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">normals_angle_difference</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Maximum angle difference between normals and the first normal.&quot;&quot;&quot;</span>
        <span class="n">max_angle</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="n">normals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normals</span>
        <span class="n">base</span> <span class="o">=</span> <span class="n">normals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">norm</span> <span class="ow">in</span> <span class="n">normals</span><span class="p">:</span>
            <span class="n">angle</span> <span class="o">=</span> <span class="n">go</span><span class="o">.</span><span class="n">vector_angle</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">norm</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">angle</span> <span class="o">&gt;</span> <span class="n">max_angle</span><span class="p">:</span>
                <span class="n">max_angle</span> <span class="o">=</span> <span class="n">angle</span>
        <span class="k">return</span> <span class="n">max_angle</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">upnormal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get upnormal for this surface.</span>

<span class="sd">        Use this value to set up rfluxmtx header.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">go</span><span class="o">.</span><span class="n">up_vector_from_points</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rad_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get and set Radiance properties.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">]</span><span class="o">.</span><span class="n">rad_properties</span>

    <span class="nd">@rad_properties.setter</span>
    <span class="k">def</span> <span class="nf">rad_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rad_properties</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">]</span><span class="o">.</span><span class="n">rad_properties</span> <span class="o">=</span> <span class="n">rad_properties</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">radiance_material</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get and set Radiance material.</span>

<span class="sd">        When you set Radiance material you can pass a Boolean to determine if the</span>
<span class="sd">        Radiance material is set by user or is based on surface type.</span>

<span class="sd">        Usage:</span>

<span class="sd">            radMat = PlasticMaterial.by_single_reflect_value(&quot;wall_material&quot;, 0.55)</span>
<span class="sd">            HBSrf.radiance_material = (radMat, True)</span>
<span class="sd">            # or</span>
<span class="sd">            HBSrf.radiance_material = radMat</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">]</span><span class="o">.</span><span class="n">radiance_material</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">]</span><span class="o">.</span><span class="n">radiance_material</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># if state doesn&#39;t have a radiance_material use the original radiance</span>
            <span class="c1"># material</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">radiance_material</span>

    <span class="nd">@radiance_material.setter</span>
    <span class="k">def</span> <span class="nf">radiance_material</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">]</span><span class="o">.</span><span class="n">rad_properties</span><span class="o">.</span><span class="n">radiance_material</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;Failed to assign new Radiance material.&#39;</span>
                                 <span class="s1">&#39; Current state does not have a RadianceProperties!&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">radiance_materials</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_rad_string</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the full list of materials including child surfaces if any.&quot;&quot;&quot;</span>
        <span class="n">mt_base</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">radiance_material</span><span class="p">]</span>
        <span class="n">mt_child</span> <span class="o">=</span> <span class="p">[</span><span class="n">childSrf</span><span class="o">.</span><span class="n">radiance_material</span> <span class="k">for</span> <span class="n">childSrf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children_surfaces</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_child_surfaces</span><span class="p">]</span>
        <span class="n">mt</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">mt_base</span> <span class="o">+</span> <span class="n">mt_child</span><span class="p">)</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">to_rad_string</span><span class="p">()</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mt</span><span class="p">)</span> <span class="k">if</span> <span class="n">to_rad_string</span> <span class="k">else</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">mt</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">duplicate_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flipped</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Duplicate surface vertices.</span>

<span class="sd">        Args:</span>
<span class="sd">            flipped: Set to True to get the vertices for the flipped surface. This is</span>
<span class="sd">                useful for cases like writing rad files for window groups in multi-phase</span>
<span class="sd">                modeling.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_child_surface</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_child_surfaces</span><span class="p">:</span>
            <span class="n">vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">absolute_points</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># get points for first glass face</span>
            <span class="n">glass_points</span> <span class="o">=</span> <span class="p">[</span><span class="n">childSrf</span><span class="o">.</span><span class="n">absolute_points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                            <span class="k">for</span> <span class="n">childSrf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children_surfaces</span><span class="p">]</span>

            <span class="n">face_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">absolute_points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">vertices</span> <span class="o">=</span> <span class="p">(</span><span class="n">AnalsysiSurfacePolyline</span><span class="p">(</span><span class="n">face_points</span><span class="p">,</span> <span class="n">glass_points</span><span class="p">)</span><span class="o">.</span><span class="n">polyline</span><span class="p">,)</span>

        <span class="k">if</span> <span class="n">flipped</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">pts</span><span class="p">))</span> <span class="k">for</span> <span class="n">pts</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">vertices</span>

    <span class="k">def</span> <span class="nf">to_rad_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">include_materials</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                      <span class="n">flipped</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">blacked</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get full radiance file as a string.</span>

<span class="sd">        Args:</span>
<span class="sd">            mode: An integer 0-2 (Default: 1)</span>
<span class="sd">                0 - Do not include children surfaces.</span>
<span class="sd">                1 - Include children surfaces.</span>
<span class="sd">                2 - Only children surfaces.</span>
<span class="sd">            include_materials: Set to False if you only want the geometry definition</span>
<span class="sd">             (default:True).</span>
<span class="sd">            flipped: Flip the surface geometry.</span>
<span class="sd">            blacked: If True materials will all be set to plastic 0 0 0 0 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span> <span class="ow">or</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">RadFile</span><span class="p">((</span><span class="bp">self</span><span class="p">,))</span><span class="o">.</span><span class="n">to_rad_string</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">include_materials</span><span class="p">,</span> <span class="n">flipped</span><span class="p">,</span> <span class="n">blacked</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rad_string_to_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_path</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">include_materials</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                           <span class="n">flipped</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">blacked</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write Radiance definition for this surface to a file.</span>

<span class="sd">        Args:</span>
<span class="sd">            filepath: Full filepath (e.g c:/ladybug/geo.rad).</span>
<span class="sd">            mode: An integer 0-2 (Default: 1)</span>
<span class="sd">                0 - Do not include children surfaces.</span>
<span class="sd">                1 - Include children surfaces.</span>
<span class="sd">                2 - Only children surfaces.</span>
<span class="sd">            include_materials: Set to False if you only want the geometry definition</span>
<span class="sd">             (default:True).</span>
<span class="sd">            flipped: Flip the surface geometry.</span>
<span class="sd">            blacked: If True materials will all be set to plastic 0 0 0 0 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span> <span class="ow">or</span> <span class="mi">1</span>
        <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">file_path</span><span class="p">)[</span><span class="mi">0</span><span class="p">]),</span> \
            <span class="s2">&quot;Cannot find </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">file_path</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">outf</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">outf</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_rad_string</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">include_materials</span><span class="p">,</span> <span class="n">flipped</span><span class="p">,</span> <span class="n">blacked</span><span class="p">))</span>
                <span class="k">return</span> <span class="bp">True</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">print</span> <span class="s2">&quot;Failed to write </span><span class="si">%s</span><span class="s2"> to file:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ep_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get and set EnergyPlus properties.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="nd">@ep_properties.setter</span>
    <span class="k">def</span> <span class="nf">ep_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ep_properties</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">ep_properties</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">energy_plus_materials</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return list of EnergyPlus materials for this surface.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="c1"># self.ep_properties.energy_plus_materials</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">energy_plus_construction</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return surface EnergyPlus construction.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="c1"># self.ep_properties.energy_plus_materials</span>

    <span class="k">def</span> <span class="nf">toep_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">include_construction</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">include_materials</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return EnergyPlus definition for this surface.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">duplicate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copy honeybee surface.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ToString</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Overwrite .NET ToString method.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Represnt Honeybee surface.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">::</span><span class="si">%s</span><span class="s2">::</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface_type</span><span class="p">))</span> \
            <span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;Surface Type: &#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">AnalsysiSurfacePolyline</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate AnalysisSurfacePolyline for surface with fenestrations.&quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;startIndex&#39;</span><span class="p">,</span> <span class="s1">&#39;_ptListA&#39;</span><span class="p">,</span> <span class="s1">&#39;_ptListB&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">surface_points</span><span class="p">,</span> <span class="n">fen_points</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Init class.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">startIndex</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ptListA</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ptListB</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__calculate_polyline</span><span class="p">(</span><span class="n">surface_points</span><span class="p">,</span> <span class="n">fen_points</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">polyline</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list of points for the single polyline.</span>

<span class="sd">        This list of points includes based surface and fenestrations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ptListB</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ptListA</span><span class="p">))</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;calculate distance between two points.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">pt2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">pt1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span>
                         <span class="p">(</span><span class="n">pt2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pt1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span>
                         <span class="p">(</span><span class="n">pt2</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">pt1</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__shortest_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pt_list1</span><span class="p">,</span> <span class="n">pt_list2</span><span class="p">):</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span>
        <span class="n">xi</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">yi</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">for</span> <span class="n">xCount</span><span class="p">,</span> <span class="n">xpt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pt_list1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">yCount</span><span class="p">,</span> <span class="n">ypt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pt_list2</span><span class="p">):</span>
                <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">xpt</span><span class="p">,</span> <span class="n">ypt</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="n">dist</span><span class="p">:</span>
                    <span class="n">dist</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span> <span class="o">=</span> <span class="n">d</span><span class="p">,</span> <span class="n">xCount</span><span class="p">,</span> <span class="n">yCount</span>

        <span class="k">return</span> <span class="n">dist</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span>

    <span class="k">def</span> <span class="nf">__add_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="n">d</span><span class="p">,</span> <span class="n">si</span><span class="p">,</span> <span class="n">ti</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__shortest_distance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">startIndex</span> <span class="o">&lt;</span> <span class="n">si</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">startIndex</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">si</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ptListA</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">source</span><span class="p">[</span><span class="n">start</span><span class="p">:</span> <span class="n">end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ptListB</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">source</span><span class="p">[</span><span class="n">end</span><span class="p">:]</span> <span class="o">+</span> <span class="n">source</span><span class="p">[:</span><span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">si</span>
            <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">startIndex</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ptListA</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">source</span><span class="p">[</span><span class="n">start</span><span class="p">:</span> <span class="n">end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ptListB</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">source</span><span class="p">[</span><span class="n">end</span><span class="p">:]</span> <span class="o">+</span> <span class="n">source</span><span class="p">[:</span><span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">startIndex</span> <span class="o">=</span> <span class="n">ti</span>

    <span class="k">def</span> <span class="nf">__calculate_polyline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">targets</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;calculate single polyline for HBSurface with Fenestration.&quot;&quot;&quot;</span>
        <span class="c1"># sort point groups</span>
        <span class="n">sorted_targets</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
            <span class="n">targets</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">target</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">__shortest_distance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__add_points</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">sorted_targets</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sorted_targets</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__calculate_polyline</span><span class="p">(</span><span class="n">sorted_targets</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sorted_targets</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__add_points</span><span class="p">(</span><span class="n">sorted_targets</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sorted_targets</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>

  </div>

  </header>

  <section id="section-items">


    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="honeybee._hbanalysissurface.AnalsysiSurfacePolyline" class="name">class <span class="ident">AnalsysiSurfacePolyline</span></p>
      
  
    <div class="desc"><p>Calculate AnalysisSurfacePolyline for surface with fenestrations.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-honeybee._hbanalysissurface.AnalsysiSurfacePolyline', this);">Show source &equiv;</a></p>
  <div id="source-honeybee._hbanalysissurface.AnalsysiSurfacePolyline" class="source">
    <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">AnalsysiSurfacePolyline</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate AnalysisSurfacePolyline for surface with fenestrations.&quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;startIndex&#39;</span><span class="p">,</span> <span class="s1">&#39;_ptListA&#39;</span><span class="p">,</span> <span class="s1">&#39;_ptListB&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">surface_points</span><span class="p">,</span> <span class="n">fen_points</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Init class.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">startIndex</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ptListA</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ptListB</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__calculate_polyline</span><span class="p">(</span><span class="n">surface_points</span><span class="p">,</span> <span class="n">fen_points</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">polyline</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list of points for the single polyline.</span>

<span class="sd">        This list of points includes based surface and fenestrations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ptListB</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ptListA</span><span class="p">))</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;calculate distance between two points.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">pt2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">pt1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span>
                         <span class="p">(</span><span class="n">pt2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pt1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span>
                         <span class="p">(</span><span class="n">pt2</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">pt1</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__shortest_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pt_list1</span><span class="p">,</span> <span class="n">pt_list2</span><span class="p">):</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span>
        <span class="n">xi</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">yi</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">for</span> <span class="n">xCount</span><span class="p">,</span> <span class="n">xpt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pt_list1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">yCount</span><span class="p">,</span> <span class="n">ypt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pt_list2</span><span class="p">):</span>
                <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">xpt</span><span class="p">,</span> <span class="n">ypt</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="n">dist</span><span class="p">:</span>
                    <span class="n">dist</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span> <span class="o">=</span> <span class="n">d</span><span class="p">,</span> <span class="n">xCount</span><span class="p">,</span> <span class="n">yCount</span>

        <span class="k">return</span> <span class="n">dist</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span>

    <span class="k">def</span> <span class="nf">__add_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="n">d</span><span class="p">,</span> <span class="n">si</span><span class="p">,</span> <span class="n">ti</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__shortest_distance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">startIndex</span> <span class="o">&lt;</span> <span class="n">si</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">startIndex</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">si</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ptListA</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">source</span><span class="p">[</span><span class="n">start</span><span class="p">:</span> <span class="n">end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ptListB</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">source</span><span class="p">[</span><span class="n">end</span><span class="p">:]</span> <span class="o">+</span> <span class="n">source</span><span class="p">[:</span><span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">si</span>
            <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">startIndex</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ptListA</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">source</span><span class="p">[</span><span class="n">start</span><span class="p">:</span> <span class="n">end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ptListB</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">source</span><span class="p">[</span><span class="n">end</span><span class="p">:]</span> <span class="o">+</span> <span class="n">source</span><span class="p">[:</span><span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">startIndex</span> <span class="o">=</span> <span class="n">ti</span>

    <span class="k">def</span> <span class="nf">__calculate_polyline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">targets</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;calculate single polyline for HBSurface with Fenestration.&quot;&quot;&quot;</span>
        <span class="c1"># sort point groups</span>
        <span class="n">sorted_targets</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
            <span class="n">targets</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">target</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">__shortest_distance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__add_points</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">sorted_targets</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sorted_targets</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__calculate_polyline</span><span class="p">(</span><span class="n">sorted_targets</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sorted_targets</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__add_points</span><span class="p">(</span><span class="n">sorted_targets</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sorted_targets</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>

  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#honeybee._hbanalysissurface.AnalsysiSurfacePolyline">AnalsysiSurfacePolyline</a></li>
          <li>__builtin__.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="honeybee._hbanalysissurface.AnalsysiSurfacePolyline.distance">
    <p>def <span class="ident">distance</span>(</p><p>pt1, pt2)</p>
    </div>
    

    
  
    <div class="desc"><p>calculate distance between two points.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-honeybee._hbanalysissurface.AnalsysiSurfacePolyline.distance', this);">Show source &equiv;</a></p>
  <div id="source-honeybee._hbanalysissurface.AnalsysiSurfacePolyline.distance" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;calculate distance between two points.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">pt2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">pt1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span>
                     <span class="p">(</span><span class="n">pt2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pt1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span>
                     <span class="p">(</span><span class="n">pt2</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">pt1</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="honeybee._hbanalysissurface.AnalsysiSurfacePolyline.polyline" class="name">var <span class="ident">polyline</span></p>
            

            
  
    <div class="desc"><p>Return a list of points for the single polyline.</p>
<p>This list of points includes based surface and fenestrations.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="honeybee._hbanalysissurface.AnalsysiSurfacePolyline.startIndex" class="name">var <span class="ident">startIndex</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="honeybee._hbanalysissurface.AnalsysiSurfacePolyline.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, surface_points, fen_points)</p>
    </div>
    

    
  
    <div class="desc"><p>Init class.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-honeybee._hbanalysissurface.AnalsysiSurfacePolyline.__init__', this);">Show source &equiv;</a></p>
  <div id="source-honeybee._hbanalysissurface.AnalsysiSurfacePolyline.__init__" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">surface_points</span><span class="p">,</span> <span class="n">fen_points</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Init class.&quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">startIndex</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_ptListA</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_ptListB</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">__calculate_polyline</span><span class="p">(</span><span class="n">surface_points</span><span class="p">,</span> <span class="n">fen_points</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="honeybee._hbanalysissurface.HBAnalysisSurface" class="name">class <span class="ident">HBAnalysisSurface</span></p>
      
  
    <div class="desc"><p>Base class for Honeybee surface.</p>
<p>Args:
    name: A unique string for surface name
    sorted_points: A list of 3 points or more as tuple or list with three items
        (x, y, z). Points should be sorted. This class won't sort the points.
        If surfaces has multiple subsurfaces you can pass lists of point lists
        to this function (e.g. ((0, 0, 0), (10, 0, 0), (0, 10, 0))).
    surface_type: Optional input for surface type. You can use any of the surface
        types available from surfacetype libraries or use a float number to
        indicate the type. If not indicated it will be assigned based on normal
        angle of the surface which will be calculated from surface points.
            0.0: Wall           0.5: UndergroundWall
            1.0: Roof           1.5: UndergroundCeiling
            2.0: Floor          2.25: UndergroundSlab
            2.5: SlabOnGrade    2.75: ExposedFloor
            3.0: Ceiling        4.0: AirWall
            5.0: Window         6.0: Context
    is_name_set_by_user: If you want the name to be changed by honeybee any case
        set is_name_set_by_user to True. Default is set to False which let Honeybee
        to rename the surface in cases like creating a newHBZone.
    states: A collection of SurfaceStates. SurfaceStates includes SurfaceProperties
        which includes the data for RadianceProperties and EPProperties and optional
        HBSurfaces. Each
        item in this collection stands for a different stae of the materials. Use
        the properties to model dynamic bahaviors such as dynamic blinds.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-honeybee._hbanalysissurface.HBAnalysisSurface', this);">Show source &equiv;</a></p>
  <div id="source-honeybee._hbanalysissurface.HBAnalysisSurface" class="source">
    <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">HBAnalysisSurface</span><span class="p">(</span><span class="n">HBObject</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class for Honeybee surface.</span>

<span class="sd">    Args:</span>
<span class="sd">        name: A unique string for surface name</span>
<span class="sd">        sorted_points: A list of 3 points or more as tuple or list with three items</span>
<span class="sd">            (x, y, z). Points should be sorted. This class won&#39;t sort the points.</span>
<span class="sd">            If surfaces has multiple subsurfaces you can pass lists of point lists</span>
<span class="sd">            to this function (e.g. ((0, 0, 0), (10, 0, 0), (0, 10, 0))).</span>
<span class="sd">        surface_type: Optional input for surface type. You can use any of the surface</span>
<span class="sd">            types available from surfacetype libraries or use a float number to</span>
<span class="sd">            indicate the type. If not indicated it will be assigned based on normal</span>
<span class="sd">            angle of the surface which will be calculated from surface points.</span>
<span class="sd">                0.0: Wall           0.5: UndergroundWall</span>
<span class="sd">                1.0: Roof           1.5: UndergroundCeiling</span>
<span class="sd">                2.0: Floor          2.25: UndergroundSlab</span>
<span class="sd">                2.5: SlabOnGrade    2.75: ExposedFloor</span>
<span class="sd">                3.0: Ceiling        4.0: AirWall</span>
<span class="sd">                5.0: Window         6.0: Context</span>
<span class="sd">        is_name_set_by_user: If you want the name to be changed by honeybee any case</span>
<span class="sd">            set is_name_set_by_user to True. Default is set to False which let Honeybee</span>
<span class="sd">            to rename the surface in cases like creating a newHBZone.</span>
<span class="sd">        states: A collection of SurfaceStates. SurfaceStates includes SurfaceProperties</span>
<span class="sd">            which includes the data for RadianceProperties and EPProperties and optional</span>
<span class="sd">            HBSurfaces. Each</span>
<span class="sd">            item in this collection stands for a different stae of the materials. Use</span>
<span class="sd">            the properties to model dynamic bahaviors such as dynamic blinds.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__metaclass__</span> <span class="o">=</span> <span class="n">ABCMeta</span>
    <span class="n">_surface_types</span> <span class="o">=</span> <span class="p">{</span><span class="mf">0.0</span><span class="p">:</span> <span class="s1">&#39;Wall&#39;</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">:</span> <span class="s1">&#39;UndergroundWall&#39;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">:</span> <span class="s1">&#39;Roof&#39;</span><span class="p">,</span>
                      <span class="mf">1.5</span><span class="p">:</span> <span class="s1">&#39;UndergroundCeiling&#39;</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">:</span> <span class="s1">&#39;Floor&#39;</span><span class="p">,</span>
                      <span class="mf">2.25</span><span class="p">:</span> <span class="s1">&#39;UndergroundSlab&#39;</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">:</span> <span class="s1">&#39;SlabOnGrade&#39;</span><span class="p">,</span>
                      <span class="mf">2.75</span><span class="p">:</span> <span class="s1">&#39;ExposedFloor&#39;</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">:</span> <span class="s1">&#39;Ceiling&#39;</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">:</span> <span class="s1">&#39;AirWall&#39;</span><span class="p">,</span>
                      <span class="mf">6.0</span><span class="p">:</span> <span class="s1">&#39;Context&#39;</span><span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">sorted_points</span><span class="p">,</span> <span class="n">surface_type</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">is_name_set_by_user</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                 <span class="n">is_type_set_by_user</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">states</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize Honeybee Surface.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_childSurfaces</span> <span class="o">=</span> <span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_states</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">random_name</span><span class="p">()</span>
            <span class="n">is_name_set_by_user</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">is_name_set_by_user</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;Surface name.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">sorted_points</span>
        <span class="sd">&quot;&quot;&quot;A list of points as tuples or lists of (x, y, z).</span>
<span class="sd">        Points should be sorted. This class won&#39;t sort the points.</span>
<span class="sd">        (e.g. ((0, 0, 0), (10, 0, 0), (0, 10, 0)))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surface_type</span> <span class="o">=</span> <span class="p">(</span><span class="n">surface_type</span><span class="p">,</span> <span class="n">is_type_set_by_user</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;Surface type.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="sd">&quot;&quot;&quot;Current state of the surface.&quot;&quot;&quot;</span>
        <span class="n">states</span> <span class="o">=</span> <span class="n">states</span> <span class="ow">or</span> \
            <span class="p">(</span><span class="n">SurfaceState</span><span class="p">(</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="n">SurfaceProperties</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surface_type</span><span class="p">)),)</span>
        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">states</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_surface_state</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_rad_ep_properties</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">sorted_points</span><span class="p">,</span> <span class="n">surface_type</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">is_name_set_by_user</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
            <span class="n">is_type_set_by_user</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">rad_properties</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ep_properties</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
            <span class="n">states</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize Honeybee Surface.</span>

<span class="sd">        RadianceProperties and EPProperties will be used to create the initial state.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">states</span> <span class="o">=</span> <span class="n">states</span> <span class="ow">or</span> <span class="p">()</span>
        <span class="c1"># create the surface first to get the surface type if not available</span>
        <span class="n">_cls</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">sorted_points</span><span class="p">,</span>
            <span class="n">surface_type</span><span class="p">,</span>
            <span class="n">is_name_set_by_user</span><span class="p">,</span>
            <span class="n">is_type_set_by_user</span><span class="p">)</span>
        <span class="c1"># replace the default properties for the initial state</span>
        <span class="n">sp</span> <span class="o">=</span> <span class="n">SurfaceProperties</span><span class="p">(</span><span class="n">_cls</span><span class="o">.</span><span class="n">surface_type</span><span class="p">,</span> <span class="n">rad_properties</span><span class="p">,</span> <span class="n">ep_properties</span><span class="p">)</span>
        <span class="n">_cls</span><span class="o">.</span><span class="n">_states</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">SurfaceState</span><span class="p">(</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="n">sp</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">states</span><span class="p">:</span>
            <span class="n">_cls</span><span class="o">.</span><span class="n">add_surface_state</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">_cls</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_hb_analysis_surface</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True for HBSurface.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_hb_surface</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True for HBSurfaces.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_hb_fen_surface</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True for HBFenSurfaces.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_hb_dynamic_surface</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True for HBSurfaces.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="nd">@abstractproperty</span>
    <span class="k">def</span> <span class="nf">is_child_surface</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if Honeybee surface is Fenestration Surface.&quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_child_surfaces</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if surface has children surfaces.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">children_surfaces</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get children surfaces.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_childSurfaces</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_bsdf_radiance_material</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if .xml BSDF material is assigned for radiance material.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_hb_fen_surface</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">radiance_material</span><span class="p">,</span> <span class="s1">&#39;xmlfile&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_radiance_glass_material</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return true if surface has radiance glass material.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">radiance_material</span><span class="o">.</span><span class="n">is_glass_material</span>

    <span class="nd">@abstractproperty</span>
    <span class="k">def</span> <span class="nf">parent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return parent for HBAnalysisSurface.</span>

<span class="sd">        Parent will be a HBZone for a HBSurface, and a HBSurface for a</span>
<span class="sd">        HBFenSurface.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_relative_system</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if coordinate system is relative.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">is_relative_system</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">origin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get origin of the coordinate system for this surface.</span>

<span class="sd">        For Absolute system the value is always (0, 0, 0).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">origin</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">state_count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of states for this surface.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The current state id.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span>

    <span class="nd">@state.setter</span>
    <span class="k">def</span> <span class="nf">state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">count</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The current state id.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">count</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_count</span><span class="p">,</span> \
                <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;This surface has only {} state. {} is an invalid state.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">state_count</span><span class="p">,</span> <span class="n">count</span>
                    <span class="p">)</span>
                <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="n">count</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">states</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;List of states for this surface.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_states</span>

    <span class="k">def</span> <span class="nf">add_surface_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">srf_state</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">srf_state</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">srf_state</span><span class="p">,</span> <span class="s1">&#39;isSurfaceState&#39;</span><span class="p">),</span> \
            <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Expected SurfaceState not {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">srf_state</span><span class="p">)))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">srf_state</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Retuen surface name.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>

    <span class="nd">@name.setter</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set name and isSetByUser property.</span>

<span class="sd">        Args:</span>
<span class="sd">            values: A name or a tuple as (name, isSetByUser)</span>

<span class="sd">        Usage:</span>
<span class="sd">            HBSrf.name = &quot;surface_001&quot;</span>
<span class="sd">            # or</span>
<span class="sd">            HBSrf.name = (&quot;mySurfaceName&quot;, True)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># check if user passed a tuple</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span>
            <span class="n">new_name</span><span class="p">,</span> <span class="n">is_name_set_by_user</span> <span class="o">=</span> <span class="n">values</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="c1"># user is passing a list or tuple with one ValueError</span>
            <span class="n">new_name</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">is_name_set_by_user</span> <span class="o">=</span> <span class="bp">False</span>  <span class="c1"># if not indicated assume it is not set by user.</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="c1"># user just passed a single value which is the name</span>
            <span class="n">new_name</span> <span class="o">=</span> <span class="n">values</span>
            <span class="n">is_name_set_by_user</span> <span class="o">=</span> <span class="bp">False</span>  <span class="c1"># if not indicated assume it is not set by user.</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="c1"># set new name</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">new_name</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_name_set_by_user</span> <span class="o">=</span> <span class="n">is_name_set_by_user</span>
            <span class="n">util</span><span class="o">.</span><span class="n">check_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_name_set_by_user</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return if name is set by user.</span>

<span class="sd">        If name is set by user the surface will never be renamed automatically.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_name_set_by_user</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">surface_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return Honeybee valid surface types.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_surface_types</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">surface_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get and set Surface Type.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_surface_type</span>

    <span class="nd">@surface_type.setter</span>
    <span class="k">def</span> <span class="nf">surface_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="c1"># let&#39;s assume values in surface_type and Boolean</span>
        <span class="n">_surface_type</span><span class="p">,</span> <span class="n">is_type_set_by_user</span> <span class="o">=</span> <span class="n">values</span>

        <span class="c1"># Now let&#39;s check the input for surface type</span>
        <span class="k">if</span> <span class="n">_surface_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c1"># it is either a number or already a valid type</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_surface_type</span><span class="p">,</span> <span class="n">surfacetype</span><span class="o">.</span><span class="n">SurfaceTypeBase</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_surface_type</span> <span class="o">=</span> <span class="n">_surface_type</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># it should be a key value</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_surface_type</span> <span class="o">=</span> \
                        <span class="n">surfacetype</span><span class="o">.</span><span class="n">SurfaceTypes</span><span class="o">.</span><span class="n">get_type_by_key</span><span class="p">(</span><span class="n">_surface_type</span><span class="p">)()</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> is not a valid surface type.&#39;</span> <span class="o">%</span> <span class="n">_surface_type</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># try to figure it out based on points</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_surface_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_surface_type_from_points</span><span class="p">()</span>
            <span class="n">is_type_set_by_user</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_is_type_set_by_user</span> <span class="o">=</span> <span class="n">is_type_set_by_user</span>

    <span class="k">def</span> <span class="nf">_surface_type_from_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">normal</span> <span class="o">=</span> <span class="n">go</span><span class="o">.</span><span class="n">normal_from_points</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">angle_to_z_axis</span> <span class="o">=</span> <span class="n">go</span><span class="o">.</span><span class="n">vector_angleToZAxis</span><span class="p">(</span><span class="n">normal</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">surfacetype</span><span class="o">.</span><span class="n">SurfaceTypes</span><span class="o">.</span><span class="n">by_normal_angle_and_points</span><span class="p">(</span><span class="n">angle_to_z_axis</span><span class="p">,</span>
                                                                   <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">])()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_type_set_by_user</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if the type for surface is set by user.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_type_set_by_user</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_floor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if surface is a Floor.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surface_type</span><span class="p">,</span> <span class="n">Floor</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_wall</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if surface is a Wall.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surface_type</span><span class="p">,</span> <span class="n">Wall</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_ceiling</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if surface is a Ceiling.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surface_type</span><span class="p">,</span> <span class="n">Ceiling</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_window</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if surface is a Window.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surface_type</span><span class="p">,</span> <span class="n">Window</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get/set points.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_points</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">absolute_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return absolute coordinates of points.</span>

<span class="sd">        If coordinate system is absolute, self.absolute_points will be the same</span>
<span class="sd">        as self.points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_relative_system</span><span class="p">:</span>
            <span class="n">ptgroups</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">count</span><span class="p">,</span> <span class="n">ptGroup</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">):</span>
                <span class="n">ptgroups</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                     <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                     <span class="n">pt</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">ptGroup</span>
                <span class="p">]</span>
            <span class="k">return</span> <span class="n">ptgroups</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span>

    <span class="nd">@points.setter</span>
    <span class="k">def</span> <span class="nf">points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pts</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;set points.</span>

<span class="sd">        Args:</span>
<span class="sd">            pts: A list of points as tuples or lists of (x, y, z).</span>
<span class="sd">            Points should be sorted. This class won&#39;t sort the points.</span>
<span class="sd">            (e.g. ((0, 0, 0), (10, 0, 0), (0, 10, 0)))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># The structure of points is list of lists so it can handle non-planar</span>
        <span class="c1"># surfaces which will have several subsurfaces. We don&#39;t check the structure</span>
        <span class="c1"># here so user can add points as needed. It will be checked once user wants</span>
        <span class="c1"># to write the surface to Radiance or EnergyPlus</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_points</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_point_list</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;is_type_set_by_user&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_type_set_by_user</span><span class="p">:</span>
            <span class="c1"># re-evaluate the type if it hasn&#39;t been set by user</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_surface_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_surface_type_from_points</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">add_point_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pts</span><span class="p">,</span> <span class="n">remove_current_points</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add new list of points to surface points.</span>

<span class="sd">        Args:</span>
<span class="sd">            pts: A list of points as tuples or lists of (x, y, z).</span>
<span class="sd">                Points should be sorted. This class won&#39;t sort the points.</span>
<span class="sd">                (e.g. ((0, 0, 0), (10, 0, 0), (0, 10, 0)))</span>
<span class="sd">            remove_current_points: Set to True to remove current points.</span>
<span class="sd">                (Default: False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">GeneratorType</span><span class="p">)),</span> \
            <span class="s1">&#39;Points should be a list or a tuple or a generator not {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">pts</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">remove_current_points</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_points</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;X&#39;</span><span class="p">):</span>
            <span class="c1"># a single list of points from Dynamo</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">((</span><span class="n">pt</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">Z</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">pts</span><span class="p">))</span>

        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;__iter__&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;X&#39;</span><span class="p">):</span>
            <span class="c1"># list of points list in Dynamo</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">tuple</span><span class="p">((</span><span class="n">pt</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">Z</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">ptGroup</span><span class="p">)</span>
                                      <span class="k">for</span> <span class="n">ptGroup</span> <span class="ow">in</span> <span class="n">pts</span><span class="p">))</span>

        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;__iter__&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;__iter__&#39;</span><span class="p">):</span>
            <span class="c1"># a list of tuples as x, y, z</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pts</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;__iter__&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;__iter__&#39;</span><span class="p">):</span>
            <span class="c1"># a list of list of tuples</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pts</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid structure for input points: {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pts</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">add_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pt</span><span class="p">,</span> <span class="n">subsurface_number</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a single point to current surface points.</span>

<span class="sd">        Args:</span>
<span class="sd">            pt: A point as (x, y, z) e.g. (20, 20, 10)</span>
<span class="sd">            subsurface_number: An optional input to indicate the subsurface that</span>
<span class="sd">            point should be added to (Default is -1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="n">subsurface_number</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="c1"># pts is a flattened list</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">pt</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c1"># input is a tuple or a generator</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="n">subsurface_number</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="n">subsurface_number</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="n">subsurface_number</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">normal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return surface normal for the first face.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">go</span><span class="o">.</span><span class="n">normal_from_points</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">normals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return surface normals for all faces.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">go</span><span class="o">.</span><span class="n">normal_from_points</span><span class="p">(</span><span class="n">pts</span><span class="p">)</span> <span class="k">for</span> <span class="n">pts</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">normals_angle_difference</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Maximum angle difference between normals and the first normal.&quot;&quot;&quot;</span>
        <span class="n">max_angle</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="n">normals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normals</span>
        <span class="n">base</span> <span class="o">=</span> <span class="n">normals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">norm</span> <span class="ow">in</span> <span class="n">normals</span><span class="p">:</span>
            <span class="n">angle</span> <span class="o">=</span> <span class="n">go</span><span class="o">.</span><span class="n">vector_angle</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">norm</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">angle</span> <span class="o">&gt;</span> <span class="n">max_angle</span><span class="p">:</span>
                <span class="n">max_angle</span> <span class="o">=</span> <span class="n">angle</span>
        <span class="k">return</span> <span class="n">max_angle</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">upnormal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get upnormal for this surface.</span>

<span class="sd">        Use this value to set up rfluxmtx header.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">go</span><span class="o">.</span><span class="n">up_vector_from_points</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rad_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get and set Radiance properties.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">]</span><span class="o">.</span><span class="n">rad_properties</span>

    <span class="nd">@rad_properties.setter</span>
    <span class="k">def</span> <span class="nf">rad_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rad_properties</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">]</span><span class="o">.</span><span class="n">rad_properties</span> <span class="o">=</span> <span class="n">rad_properties</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">radiance_material</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get and set Radiance material.</span>

<span class="sd">        When you set Radiance material you can pass a Boolean to determine if the</span>
<span class="sd">        Radiance material is set by user or is based on surface type.</span>

<span class="sd">        Usage:</span>

<span class="sd">            radMat = PlasticMaterial.by_single_reflect_value(&quot;wall_material&quot;, 0.55)</span>
<span class="sd">            HBSrf.radiance_material = (radMat, True)</span>
<span class="sd">            # or</span>
<span class="sd">            HBSrf.radiance_material = radMat</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">]</span><span class="o">.</span><span class="n">radiance_material</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">]</span><span class="o">.</span><span class="n">radiance_material</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># if state doesn&#39;t have a radiance_material use the original radiance</span>
            <span class="c1"># material</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">radiance_material</span>

    <span class="nd">@radiance_material.setter</span>
    <span class="k">def</span> <span class="nf">radiance_material</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">]</span><span class="o">.</span><span class="n">rad_properties</span><span class="o">.</span><span class="n">radiance_material</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;Failed to assign new Radiance material.&#39;</span>
                                 <span class="s1">&#39; Current state does not have a RadianceProperties!&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">radiance_materials</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_rad_string</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the full list of materials including child surfaces if any.&quot;&quot;&quot;</span>
        <span class="n">mt_base</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">radiance_material</span><span class="p">]</span>
        <span class="n">mt_child</span> <span class="o">=</span> <span class="p">[</span><span class="n">childSrf</span><span class="o">.</span><span class="n">radiance_material</span> <span class="k">for</span> <span class="n">childSrf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children_surfaces</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_child_surfaces</span><span class="p">]</span>
        <span class="n">mt</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">mt_base</span> <span class="o">+</span> <span class="n">mt_child</span><span class="p">)</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">to_rad_string</span><span class="p">()</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mt</span><span class="p">)</span> <span class="k">if</span> <span class="n">to_rad_string</span> <span class="k">else</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">mt</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">duplicate_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flipped</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Duplicate surface vertices.</span>

<span class="sd">        Args:</span>
<span class="sd">            flipped: Set to True to get the vertices for the flipped surface. This is</span>
<span class="sd">                useful for cases like writing rad files for window groups in multi-phase</span>
<span class="sd">                modeling.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_child_surface</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_child_surfaces</span><span class="p">:</span>
            <span class="n">vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">absolute_points</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># get points for first glass face</span>
            <span class="n">glass_points</span> <span class="o">=</span> <span class="p">[</span><span class="n">childSrf</span><span class="o">.</span><span class="n">absolute_points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                            <span class="k">for</span> <span class="n">childSrf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children_surfaces</span><span class="p">]</span>

            <span class="n">face_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">absolute_points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">vertices</span> <span class="o">=</span> <span class="p">(</span><span class="n">AnalsysiSurfacePolyline</span><span class="p">(</span><span class="n">face_points</span><span class="p">,</span> <span class="n">glass_points</span><span class="p">)</span><span class="o">.</span><span class="n">polyline</span><span class="p">,)</span>

        <span class="k">if</span> <span class="n">flipped</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">pts</span><span class="p">))</span> <span class="k">for</span> <span class="n">pts</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">vertices</span>

    <span class="k">def</span> <span class="nf">to_rad_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">include_materials</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                      <span class="n">flipped</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">blacked</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get full radiance file as a string.</span>

<span class="sd">        Args:</span>
<span class="sd">            mode: An integer 0-2 (Default: 1)</span>
<span class="sd">                0 - Do not include children surfaces.</span>
<span class="sd">                1 - Include children surfaces.</span>
<span class="sd">                2 - Only children surfaces.</span>
<span class="sd">            include_materials: Set to False if you only want the geometry definition</span>
<span class="sd">             (default:True).</span>
<span class="sd">            flipped: Flip the surface geometry.</span>
<span class="sd">            blacked: If True materials will all be set to plastic 0 0 0 0 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span> <span class="ow">or</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">RadFile</span><span class="p">((</span><span class="bp">self</span><span class="p">,))</span><span class="o">.</span><span class="n">to_rad_string</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">include_materials</span><span class="p">,</span> <span class="n">flipped</span><span class="p">,</span> <span class="n">blacked</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rad_string_to_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_path</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">include_materials</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                           <span class="n">flipped</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">blacked</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write Radiance definition for this surface to a file.</span>

<span class="sd">        Args:</span>
<span class="sd">            filepath: Full filepath (e.g c:/ladybug/geo.rad).</span>
<span class="sd">            mode: An integer 0-2 (Default: 1)</span>
<span class="sd">                0 - Do not include children surfaces.</span>
<span class="sd">                1 - Include children surfaces.</span>
<span class="sd">                2 - Only children surfaces.</span>
<span class="sd">            include_materials: Set to False if you only want the geometry definition</span>
<span class="sd">             (default:True).</span>
<span class="sd">            flipped: Flip the surface geometry.</span>
<span class="sd">            blacked: If True materials will all be set to plastic 0 0 0 0 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span> <span class="ow">or</span> <span class="mi">1</span>
        <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">file_path</span><span class="p">)[</span><span class="mi">0</span><span class="p">]),</span> \
            <span class="s2">&quot;Cannot find </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">file_path</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">outf</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">outf</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_rad_string</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">include_materials</span><span class="p">,</span> <span class="n">flipped</span><span class="p">,</span> <span class="n">blacked</span><span class="p">))</span>
                <span class="k">return</span> <span class="bp">True</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">print</span> <span class="s2">&quot;Failed to write </span><span class="si">%s</span><span class="s2"> to file:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ep_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get and set EnergyPlus properties.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="nd">@ep_properties.setter</span>
    <span class="k">def</span> <span class="nf">ep_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ep_properties</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">ep_properties</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">energy_plus_materials</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return list of EnergyPlus materials for this surface.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="c1"># self.ep_properties.energy_plus_materials</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">energy_plus_construction</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return surface EnergyPlus construction.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="c1"># self.ep_properties.energy_plus_materials</span>

    <span class="k">def</span> <span class="nf">toep_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">include_construction</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">include_materials</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return EnergyPlus definition for this surface.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">duplicate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copy honeybee surface.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ToString</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Overwrite .NET ToString method.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Represnt Honeybee surface.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">::</span><span class="si">%s</span><span class="s2">::</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface_type</span><span class="p">))</span> \
            <span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;Surface Type: &#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
</pre></div>

  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#honeybee._hbanalysissurface.HBAnalysisSurface">HBAnalysisSurface</a></li>
          <li>honeybee.hbobject.HBObject</li>
          <li>__builtin__.object</li>
          </ul>
          <h3>Instance variables</h3>
            <div class="item">
            <p id="honeybee._hbanalysissurface.HBAnalysisSurface.absolute_points" class="name">var <span class="ident">absolute_points</span></p>
            

            
  
    <div class="desc"><p>Return absolute coordinates of points.</p>
<p>If coordinate system is absolute, self.absolute_points will be the same
as self.points.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="honeybee._hbanalysissurface.HBAnalysisSurface.children_surfaces" class="name">var <span class="ident">children_surfaces</span></p>
            

            
  
    <div class="desc"><p>Get children surfaces.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="honeybee._hbanalysissurface.HBAnalysisSurface.energy_plus_construction" class="name">var <span class="ident">energy_plus_construction</span></p>
            

            
  
    <div class="desc"><p>Return surface EnergyPlus construction.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="honeybee._hbanalysissurface.HBAnalysisSurface.energy_plus_materials" class="name">var <span class="ident">energy_plus_materials</span></p>
            

            
  
    <div class="desc"><p>Return list of EnergyPlus materials for this surface.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="honeybee._hbanalysissurface.HBAnalysisSurface.ep_properties" class="name">var <span class="ident">ep_properties</span></p>
            

            
  
    <div class="desc"><p>Get and set EnergyPlus properties.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="honeybee._hbanalysissurface.HBAnalysisSurface.has_bsdf_radiance_material" class="name">var <span class="ident">has_bsdf_radiance_material</span></p>
            

            
  
    <div class="desc"><p>Return True if .xml BSDF material is assigned for radiance material.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="honeybee._hbanalysissurface.HBAnalysisSurface.has_child_surfaces" class="name">var <span class="ident">has_child_surfaces</span></p>
            

            
  
    <div class="desc"><p>Return True if surface has children surfaces.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="honeybee._hbanalysissurface.HBAnalysisSurface.has_radiance_glass_material" class="name">var <span class="ident">has_radiance_glass_material</span></p>
            

            
  
    <div class="desc"><p>Return true if surface has radiance glass material.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="honeybee._hbanalysissurface.HBAnalysisSurface.is_ceiling" class="name">var <span class="ident">is_ceiling</span></p>
            

            
  
    <div class="desc"><p>Check if surface is a Ceiling.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="honeybee._hbanalysissurface.HBAnalysisSurface.is_child_surface" class="name">var <span class="ident">is_child_surface</span></p>
            

            
  
    <div class="desc"><p>Return True if Honeybee surface is Fenestration Surface.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="honeybee._hbanalysissurface.HBAnalysisSurface.is_floor" class="name">var <span class="ident">is_floor</span></p>
            

            
  
    <div class="desc"><p>Check if surface is a Floor.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="honeybee._hbanalysissurface.HBAnalysisSurface.is_hb_analysis_surface" class="name">var <span class="ident">is_hb_analysis_surface</span></p>
            

            
  
    <div class="desc"><p>Return True for HBSurface.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="honeybee._hbanalysissurface.HBAnalysisSurface.is_hb_dynamic_surface" class="name">var <span class="ident">is_hb_dynamic_surface</span></p>
            

            
  
    <div class="desc"><p>Return True for HBSurfaces.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="honeybee._hbanalysissurface.HBAnalysisSurface.is_hb_fen_surface" class="name">var <span class="ident">is_hb_fen_surface</span></p>
            

            
  
    <div class="desc"><p>Return True for HBFenSurfaces.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="honeybee._hbanalysissurface.HBAnalysisSurface.is_hb_object" class="name">var <span class="ident">is_hb_object</span></p>
            

            
  
    <div class="desc"><p>Return True.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="honeybee._hbanalysissurface.HBAnalysisSurface.is_hb_surface" class="name">var <span class="ident">is_hb_surface</span></p>
            

            
  
    <div class="desc"><p>Return True for HBSurfaces.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="honeybee._hbanalysissurface.HBAnalysisSurface.is_name_set_by_user" class="name">var <span class="ident">is_name_set_by_user</span></p>
            

            
  
    <div class="desc"><p>Return if name is set by user.</p>
<p>If name is set by user the surface will never be renamed automatically.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="honeybee._hbanalysissurface.HBAnalysisSurface.is_relative_system" class="name">var <span class="ident">is_relative_system</span></p>
            

            
  
    <div class="desc"><p>Return True if coordinate system is relative.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="honeybee._hbanalysissurface.HBAnalysisSurface.is_type_set_by_user" class="name">var <span class="ident">is_type_set_by_user</span></p>
            

            
  
    <div class="desc"><p>Check if the type for surface is set by user.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="honeybee._hbanalysissurface.HBAnalysisSurface.is_wall" class="name">var <span class="ident">is_wall</span></p>
            

            
  
    <div class="desc"><p>Check if surface is a Wall.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="honeybee._hbanalysissurface.HBAnalysisSurface.is_window" class="name">var <span class="ident">is_window</span></p>
            

            
  
    <div class="desc"><p>Check if surface is a Window.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="honeybee._hbanalysissurface.HBAnalysisSurface.name" class="name">var <span class="ident">name</span></p>
            

            
  
    <div class="desc"><p>Surface name.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="honeybee._hbanalysissurface.HBAnalysisSurface.normal" class="name">var <span class="ident">normal</span></p>
            

            
  
    <div class="desc"><p>Return surface normal for the first face.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="honeybee._hbanalysissurface.HBAnalysisSurface.normals" class="name">var <span class="ident">normals</span></p>
            

            
  
    <div class="desc"><p>Return surface normals for all faces.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="honeybee._hbanalysissurface.HBAnalysisSurface.normals_angle_difference" class="name">var <span class="ident">normals_angle_difference</span></p>
            

            
  
    <div class="desc"><p>Maximum angle difference between normals and the first normal.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="honeybee._hbanalysissurface.HBAnalysisSurface.origin" class="name">var <span class="ident">origin</span></p>
            

            
  
    <div class="desc"><p>Get origin of the coordinate system for this surface.</p>
<p>For Absolute system the value is always (0, 0, 0).</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="honeybee._hbanalysissurface.HBAnalysisSurface.parent" class="name">var <span class="ident">parent</span></p>
            

            
  
    <div class="desc"><p>Return parent for HBAnalysisSurface.</p>
<p>Parent will be a HBZone for a HBSurface, and a HBSurface for a
HBFenSurface.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="honeybee._hbanalysissurface.HBAnalysisSurface.points" class="name">var <span class="ident">points</span></p>
            

            
  
    <div class="desc"><p>A list of points as tuples or lists of (x, y, z).
Points should be sorted. This class won't sort the points.
(e.g. ((0, 0, 0), (10, 0, 0), (0, 10, 0)))</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="honeybee._hbanalysissurface.HBAnalysisSurface.rad_properties" class="name">var <span class="ident">rad_properties</span></p>
            

            
  
    <div class="desc"><p>Get and set Radiance properties.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="honeybee._hbanalysissurface.HBAnalysisSurface.radiance_material" class="name">var <span class="ident">radiance_material</span></p>
            

            
  
    <div class="desc"><p>Get and set Radiance material.</p>
<p>When you set Radiance material you can pass a Boolean to determine if the
Radiance material is set by user or is based on surface type.</p>
<p>Usage:</p>
<div class="codehilite"><pre><span></span>radMat = PlasticMaterial.by_single_reflect_value(&quot;wall_material&quot;, 0.55)
HBSrf.radiance_material = (radMat, True)
# or
HBSrf.radiance_material = radMat
</pre></div></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="honeybee._hbanalysissurface.HBAnalysisSurface.state" class="name">var <span class="ident">state</span></p>
            

            
  
    <div class="desc"><p>Current state of the surface.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="honeybee._hbanalysissurface.HBAnalysisSurface.state_count" class="name">var <span class="ident">state_count</span></p>
            

            
  
    <div class="desc"><p>Number of states for this surface.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="honeybee._hbanalysissurface.HBAnalysisSurface.states" class="name">var <span class="ident">states</span></p>
            

            
  
    <div class="desc"><p>List of states for this surface.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="honeybee._hbanalysissurface.HBAnalysisSurface.surface_type" class="name">var <span class="ident">surface_type</span></p>
            

            
  
    <div class="desc"><p>Surface type.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="honeybee._hbanalysissurface.HBAnalysisSurface.surface_types" class="name">var <span class="ident">surface_types</span></p>
            

            
  
    <div class="desc"><p>Return Honeybee valid surface types.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="honeybee._hbanalysissurface.HBAnalysisSurface.upnormal" class="name">var <span class="ident">upnormal</span></p>
            

            
  
    <div class="desc"><p>Get upnormal for this surface.</p>
<p>Use this value to set up rfluxmtx header.</p></div>
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="honeybee._hbanalysissurface.HBAnalysisSurface.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, name, sorted_points, surface_type=None, is_name_set_by_user=False, is_type_set_by_user=False, states=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Initialize Honeybee Surface.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-honeybee._hbanalysissurface.HBAnalysisSurface.__init__', this);">Show source &equiv;</a></p>
  <div id="source-honeybee._hbanalysissurface.HBAnalysisSurface.__init__" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">sorted_points</span><span class="p">,</span> <span class="n">surface_type</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">is_name_set_by_user</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
             <span class="n">is_type_set_by_user</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">states</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Initialize Honeybee Surface.&quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_childSurfaces</span> <span class="o">=</span> <span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_states</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">random_name</span><span class="p">()</span>
        <span class="n">is_name_set_by_user</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">is_name_set_by_user</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;Surface name.&quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">sorted_points</span>
    <span class="sd">&quot;&quot;&quot;A list of points as tuples or lists of (x, y, z).</span>
<span class="sd">    Points should be sorted. This class won&#39;t sort the points.</span>
<span class="sd">    (e.g. ((0, 0, 0), (10, 0, 0), (0, 10, 0)))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">surface_type</span> <span class="o">=</span> <span class="p">(</span><span class="n">surface_type</span><span class="p">,</span> <span class="n">is_type_set_by_user</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;Surface type.&quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="sd">&quot;&quot;&quot;Current state of the surface.&quot;&quot;&quot;</span>
    <span class="n">states</span> <span class="o">=</span> <span class="n">states</span> <span class="ow">or</span> \
        <span class="p">(</span><span class="n">SurfaceState</span><span class="p">(</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="n">SurfaceProperties</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surface_type</span><span class="p">)),)</span>
    <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">states</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_surface_state</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="honeybee._hbanalysissurface.HBAnalysisSurface.ToString">
    <p>def <span class="ident">ToString</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Overwrite .NET ToString method.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-honeybee._hbanalysissurface.HBAnalysisSurface.ToString', this);">Show source &equiv;</a></p>
  <div id="source-honeybee._hbanalysissurface.HBAnalysisSurface.ToString" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">ToString</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Overwrite .NET ToString method.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="honeybee._hbanalysissurface.HBAnalysisSurface.add_point">
    <p>def <span class="ident">add_point</span>(</p><p>self, pt, subsurface_number=-1)</p>
    </div>
    

    
  
    <div class="desc"><p>Add a single point to current surface points.</p>
<p>Args:
    pt: A point as (x, y, z) e.g. (20, 20, 10)
    subsurface_number: An optional input to indicate the subsurface that
    point should be added to (Default is -1)</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-honeybee._hbanalysissurface.HBAnalysisSurface.add_point', this);">Show source &equiv;</a></p>
  <div id="source-honeybee._hbanalysissurface.HBAnalysisSurface.add_point" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">add_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pt</span><span class="p">,</span> <span class="n">subsurface_number</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Add a single point to current surface points.</span>
<span class="sd">    Args:</span>
<span class="sd">        pt: A point as (x, y, z) e.g. (20, 20, 10)</span>
<span class="sd">        subsurface_number: An optional input to indicate the subsurface that</span>
<span class="sd">        point should be added to (Default is -1)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="n">subsurface_number</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
        <span class="c1"># pts is a flattened list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">pt</span><span class="p">])</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="c1"># input is a tuple or a generator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="n">subsurface_number</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="n">subsurface_number</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="n">subsurface_number</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="honeybee._hbanalysissurface.HBAnalysisSurface.add_point_list">
    <p>def <span class="ident">add_point_list</span>(</p><p>self, pts, remove_current_points=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Add new list of points to surface points.</p>
<p>Args:
    pts: A list of points as tuples or lists of (x, y, z).
        Points should be sorted. This class won't sort the points.
        (e.g. ((0, 0, 0), (10, 0, 0), (0, 10, 0)))
    remove_current_points: Set to True to remove current points.
        (Default: False)</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-honeybee._hbanalysissurface.HBAnalysisSurface.add_point_list', this);">Show source &equiv;</a></p>
  <div id="source-honeybee._hbanalysissurface.HBAnalysisSurface.add_point_list" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">add_point_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pts</span><span class="p">,</span> <span class="n">remove_current_points</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Add new list of points to surface points.</span>
<span class="sd">    Args:</span>
<span class="sd">        pts: A list of points as tuples or lists of (x, y, z).</span>
<span class="sd">            Points should be sorted. This class won&#39;t sort the points.</span>
<span class="sd">            (e.g. ((0, 0, 0), (10, 0, 0), (0, 10, 0)))</span>
<span class="sd">        remove_current_points: Set to True to remove current points.</span>
<span class="sd">            (Default: False)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">GeneratorType</span><span class="p">)),</span> \
        <span class="s1">&#39;Points should be a list or a tuple or a generator not {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">pts</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="k">if</span> <span class="n">remove_current_points</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_points</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;X&#39;</span><span class="p">):</span>
        <span class="c1"># a single list of points from Dynamo</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">((</span><span class="n">pt</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">Z</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">pts</span><span class="p">))</span>
    <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;__iter__&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;X&#39;</span><span class="p">):</span>
        <span class="c1"># list of points list in Dynamo</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">tuple</span><span class="p">((</span><span class="n">pt</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">Z</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">ptGroup</span><span class="p">)</span>
                                  <span class="k">for</span> <span class="n">ptGroup</span> <span class="ow">in</span> <span class="n">pts</span><span class="p">))</span>
    <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;__iter__&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;__iter__&#39;</span><span class="p">):</span>
        <span class="c1"># a list of tuples as x, y, z</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pts</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;__iter__&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;__iter__&#39;</span><span class="p">):</span>
        <span class="c1"># a list of list of tuples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pts</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid structure for input points: {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pts</span><span class="p">))</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="honeybee._hbanalysissurface.HBAnalysisSurface.add_surface_state">
    <p>def <span class="ident">add_surface_state</span>(</p><p>self, srf_state)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-honeybee._hbanalysissurface.HBAnalysisSurface.add_surface_state', this);">Show source &equiv;</a></p>
  <div id="source-honeybee._hbanalysissurface.HBAnalysisSurface.add_surface_state" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">add_surface_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">srf_state</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">srf_state</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">srf_state</span><span class="p">,</span> <span class="s1">&#39;isSurfaceState&#39;</span><span class="p">),</span> \
        <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Expected SurfaceState not {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">srf_state</span><span class="p">)))</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">srf_state</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="honeybee._hbanalysissurface.HBAnalysisSurface.duplicate">
    <p>def <span class="ident">duplicate</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Copy honeybee surface.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-honeybee._hbanalysissurface.HBAnalysisSurface.duplicate', this);">Show source &equiv;</a></p>
  <div id="source-honeybee._hbanalysissurface.HBAnalysisSurface.duplicate" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">duplicate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Copy honeybee surface.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="honeybee._hbanalysissurface.HBAnalysisSurface.duplicate_vertices">
    <p>def <span class="ident">duplicate_vertices</span>(</p><p>self, flipped=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Duplicate surface vertices.</p>
<p>Args:
    flipped: Set to True to get the vertices for the flipped surface. This is
        useful for cases like writing rad files for window groups in multi-phase
        modeling.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-honeybee._hbanalysissurface.HBAnalysisSurface.duplicate_vertices', this);">Show source &equiv;</a></p>
  <div id="source-honeybee._hbanalysissurface.HBAnalysisSurface.duplicate_vertices" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">duplicate_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flipped</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Duplicate surface vertices.</span>
<span class="sd">    Args:</span>
<span class="sd">        flipped: Set to True to get the vertices for the flipped surface. This is</span>
<span class="sd">            useful for cases like writing rad files for window groups in multi-phase</span>
<span class="sd">            modeling.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_child_surface</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_child_surfaces</span><span class="p">:</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">absolute_points</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># get points for first glass face</span>
        <span class="n">glass_points</span> <span class="o">=</span> <span class="p">[</span><span class="n">childSrf</span><span class="o">.</span><span class="n">absolute_points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">childSrf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children_surfaces</span><span class="p">]</span>
        <span class="n">face_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">absolute_points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="p">(</span><span class="n">AnalsysiSurfacePolyline</span><span class="p">(</span><span class="n">face_points</span><span class="p">,</span> <span class="n">glass_points</span><span class="p">)</span><span class="o">.</span><span class="n">polyline</span><span class="p">,)</span>
    <span class="k">if</span> <span class="n">flipped</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">pts</span><span class="p">))</span> <span class="k">for</span> <span class="n">pts</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">vertices</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="honeybee._hbanalysissurface.HBAnalysisSurface.from_rad_ep_properties">
    <p>def <span class="ident">from_rad_ep_properties</span>(</p><p>cls, name, sorted_points, surface_type=None, is_name_set_by_user=False, is_type_set_by_user=False, rad_properties=None, ep_properties=None, states=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Initialize Honeybee Surface.</p>
<p>RadianceProperties and EPProperties will be used to create the initial state.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-honeybee._hbanalysissurface.HBAnalysisSurface.from_rad_ep_properties', this);">Show source &equiv;</a></p>
  <div id="source-honeybee._hbanalysissurface.HBAnalysisSurface.from_rad_ep_properties" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">from_rad_ep_properties</span><span class="p">(</span>
    <span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">sorted_points</span><span class="p">,</span> <span class="n">surface_type</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">is_name_set_by_user</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
        <span class="n">is_type_set_by_user</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">rad_properties</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ep_properties</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
        <span class="n">states</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Initialize Honeybee Surface.</span>
<span class="sd">    RadianceProperties and EPProperties will be used to create the initial state.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">states</span> <span class="o">=</span> <span class="n">states</span> <span class="ow">or</span> <span class="p">()</span>
    <span class="c1"># create the surface first to get the surface type if not available</span>
    <span class="n">_cls</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span>
        <span class="n">name</span><span class="p">,</span>
        <span class="n">sorted_points</span><span class="p">,</span>
        <span class="n">surface_type</span><span class="p">,</span>
        <span class="n">is_name_set_by_user</span><span class="p">,</span>
        <span class="n">is_type_set_by_user</span><span class="p">)</span>
    <span class="c1"># replace the default properties for the initial state</span>
    <span class="n">sp</span> <span class="o">=</span> <span class="n">SurfaceProperties</span><span class="p">(</span><span class="n">_cls</span><span class="o">.</span><span class="n">surface_type</span><span class="p">,</span> <span class="n">rad_properties</span><span class="p">,</span> <span class="n">ep_properties</span><span class="p">)</span>
    <span class="n">_cls</span><span class="o">.</span><span class="n">_states</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">SurfaceState</span><span class="p">(</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="n">sp</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">states</span><span class="p">:</span>
        <span class="n">_cls</span><span class="o">.</span><span class="n">add_surface_state</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_cls</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="honeybee._hbanalysissurface.HBAnalysisSurface.rad_string_to_file">
    <p>def <span class="ident">rad_string_to_file</span>(</p><p>self, file_path, mode=1, include_materials=False, flipped=False, blacked=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Write Radiance definition for this surface to a file.</p>
<p>Args:
    filepath: Full filepath (e.g c:/ladybug/geo.rad).
    mode: An integer 0-2 (Default: 1)
        0 - Do not include children surfaces.
        1 - Include children surfaces.
        2 - Only children surfaces.
    include_materials: Set to False if you only want the geometry definition
     (default:True).
    flipped: Flip the surface geometry.
    blacked: If True materials will all be set to plastic 0 0 0 0 0.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-honeybee._hbanalysissurface.HBAnalysisSurface.rad_string_to_file', this);">Show source &equiv;</a></p>
  <div id="source-honeybee._hbanalysissurface.HBAnalysisSurface.rad_string_to_file" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">rad_string_to_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_path</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">include_materials</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                       <span class="n">flipped</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">blacked</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Write Radiance definition for this surface to a file.</span>
<span class="sd">    Args:</span>
<span class="sd">        filepath: Full filepath (e.g c:/ladybug/geo.rad).</span>
<span class="sd">        mode: An integer 0-2 (Default: 1)</span>
<span class="sd">            0 - Do not include children surfaces.</span>
<span class="sd">            1 - Include children surfaces.</span>
<span class="sd">            2 - Only children surfaces.</span>
<span class="sd">        include_materials: Set to False if you only want the geometry definition</span>
<span class="sd">         (default:True).</span>
<span class="sd">        flipped: Flip the surface geometry.</span>
<span class="sd">        blacked: If True materials will all be set to plastic 0 0 0 0 0.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span> <span class="ow">or</span> <span class="mi">1</span>
    <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">file_path</span><span class="p">)[</span><span class="mi">0</span><span class="p">]),</span> \
        <span class="s2">&quot;Cannot find </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">file_path</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">outf</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">outf</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_rad_string</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">include_materials</span><span class="p">,</span> <span class="n">flipped</span><span class="p">,</span> <span class="n">blacked</span><span class="p">))</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">print</span> <span class="s2">&quot;Failed to write </span><span class="si">%s</span><span class="s2"> to file:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">False</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="honeybee._hbanalysissurface.HBAnalysisSurface.radiance_materials">
    <p>def <span class="ident">radiance_materials</span>(</p><p>self, to_rad_string=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Get the full list of materials including child surfaces if any.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-honeybee._hbanalysissurface.HBAnalysisSurface.radiance_materials', this);">Show source &equiv;</a></p>
  <div id="source-honeybee._hbanalysissurface.HBAnalysisSurface.radiance_materials" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">radiance_materials</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_rad_string</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get the full list of materials including child surfaces if any.&quot;&quot;&quot;</span>
    <span class="n">mt_base</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">radiance_material</span><span class="p">]</span>
    <span class="n">mt_child</span> <span class="o">=</span> <span class="p">[</span><span class="n">childSrf</span><span class="o">.</span><span class="n">radiance_material</span> <span class="k">for</span> <span class="n">childSrf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children_surfaces</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_child_surfaces</span><span class="p">]</span>
    <span class="n">mt</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">mt_base</span> <span class="o">+</span> <span class="n">mt_child</span><span class="p">)</span>
    <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">to_rad_string</span><span class="p">()</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mt</span><span class="p">)</span> <span class="k">if</span> <span class="n">to_rad_string</span> <span class="k">else</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">mt</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="honeybee._hbanalysissurface.HBAnalysisSurface.to_rad_string">
    <p>def <span class="ident">to_rad_string</span>(</p><p>self, mode=1, include_materials=False, flipped=False, blacked=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Get full radiance file as a string.</p>
<p>Args:
    mode: An integer 0-2 (Default: 1)
        0 - Do not include children surfaces.
        1 - Include children surfaces.
        2 - Only children surfaces.
    include_materials: Set to False if you only want the geometry definition
     (default:True).
    flipped: Flip the surface geometry.
    blacked: If True materials will all be set to plastic 0 0 0 0 0.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-honeybee._hbanalysissurface.HBAnalysisSurface.to_rad_string', this);">Show source &equiv;</a></p>
  <div id="source-honeybee._hbanalysissurface.HBAnalysisSurface.to_rad_string" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">to_rad_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">include_materials</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                  <span class="n">flipped</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">blacked</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get full radiance file as a string.</span>
<span class="sd">    Args:</span>
<span class="sd">        mode: An integer 0-2 (Default: 1)</span>
<span class="sd">            0 - Do not include children surfaces.</span>
<span class="sd">            1 - Include children surfaces.</span>
<span class="sd">            2 - Only children surfaces.</span>
<span class="sd">        include_materials: Set to False if you only want the geometry definition</span>
<span class="sd">         (default:True).</span>
<span class="sd">        flipped: Flip the surface geometry.</span>
<span class="sd">        blacked: If True materials will all be set to plastic 0 0 0 0 0.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span> <span class="ow">or</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">RadFile</span><span class="p">((</span><span class="bp">self</span><span class="p">,))</span><span class="o">.</span><span class="n">to_rad_string</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">include_materials</span><span class="p">,</span> <span class="n">flipped</span><span class="p">,</span> <span class="n">blacked</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="honeybee._hbanalysissurface.HBAnalysisSurface.toep_string">
    <p>def <span class="ident">toep_string</span>(</p><p>self, include_construction=False, include_materials=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Return EnergyPlus definition for this surface.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-honeybee._hbanalysissurface.HBAnalysisSurface.toep_string', this);">Show source &equiv;</a></p>
  <div id="source-honeybee._hbanalysissurface.HBAnalysisSurface.toep_string" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">toep_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">include_construction</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">include_materials</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return EnergyPlus definition for this surface.&quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span>
</pre></div>

  </div>
</div>

  </div>
  
      </div>
      </div>

  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.2</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a></p>
  </footer>
</div>
</body>
</html>